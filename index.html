<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG図形変形ツール（400px×400px版）- 頂点の丸み改善</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-bottom: 20px; }
        input { margin-right: 10px; }
        #svgContainer { border: 2px solid black; }
    </style>
</head>
<body>
    <h1>SVG図形変形ツール（400px×400px版）- 頂点の丸み改善</h1>
    <div id="controls">
        <input type="file" id="svgFile" accept=".svg">
        <input type="range" id="vertexCount" min="3" max="20" value="4">
        <label for="vertexCount">頂点数: <span id="vertexCountValue">4</span></label>
        <input type="range" id="roundness" min="0" max="100" value="0">
        <label for="roundness">丸み: <span id="roundnessValue">0</span></label>
        <input type="range" id="rotation" min="0" max="360" value="0">
        <label for="rotation">回転: <span id="rotationValue">0</span>°</label>
    </div>
    <svg id="svgContainer" width="400" height="400"></svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.1/svg.min.js"></script>
    <script>
        const svgContainer = SVG('#svgContainer');
        let shape;

        document.getElementById('svgFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                svgContainer.clear();
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = event.target.result;
                const svgElement = tempContainer.querySelector('svg');
                const viewBox = svgElement.getAttribute('viewBox');
                if (viewBox) {
                    svgContainer.attr('viewBox', viewBox);
                }
                shape = SVG(svgElement.querySelector('path'));
                svgContainer.add(shape);
                centerAndScaleShape();
                updateShape();
            };
            reader.readAsText(file);
        });

        ['vertexCount', 'roundness', 'rotation'].forEach(id => {
            const input = document.getElementById(id);
            const value = document.getElementById(`${id}Value`);
            input.addEventListener('input', () => {
                value.textContent = input.value;
                updateShape();
            });
        });

        function centerAndScaleShape() {
            const bbox = shape.bbox();
            const scale = Math.min(380 / bbox.width, 380 / bbox.height);
            shape.transform({
                translateX: (400 - bbox.width * scale) / 2 - bbox.x * scale,
                translateY: (400 - bbox.height * scale) / 2 - bbox.y * scale,
                scale: scale
            });
        }

        function updateShape() {
            if (!shape) return;

            const vertexCount = parseInt(document.getElementById('vertexCount').value);
            const roundness = parseInt(document.getElementById('roundness').value) / 100;
            const rotation = parseInt(document.getElementById('rotation').value);

            const bbox = shape.bbox();
            const radius = Math.min(bbox.width, bbox.height) / 2;
            const center = { x: bbox.cx, y: bbox.cy };
            let path = '';

            for (let i = 0; i < vertexCount; i++) {
                const angle = (i / vertexCount) * Math.PI * 2 + (rotation * Math.PI / 180);
                const nextAngle = ((i + 1) / vertexCount) * Math.PI * 2 + (rotation * Math.PI / 180);
                
                const x = center.x + radius * Math.cos(angle);
                const y = center.y + radius * Math.sin(angle);
                const nextX = center.x + radius * Math.cos(nextAngle);
                const nextY = center.y + radius * Math.sin(nextAngle);

                if (i === 0) {
                    path += `M${x},${y}`;
                }

                // Calculate control points for quadratic Bezier curve
                const midX = (x + nextX) / 2;
                const midY = (y + nextY) / 2;
                const dx = nextX - x;
                const dy = nextY - y;
                const normX = -dy;
                const normY = dx;
                const dist = Math.sqrt(normX * normX + normY * normY);
                const controlX = midX + (normX / dist) * radius * roundness;
                const controlY = midY + (normY / dist) * radius * roundness;

                path += `Q${controlX},${controlY} ${nextX},${nextY}`;
            }

            path += 'Z';
            shape.plot(path);
        }
    </script>
</body>
</html>
