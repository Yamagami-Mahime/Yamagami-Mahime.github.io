<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas & SVG図形変形ツール</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-bottom: 20px; }
        input { margin-right: 10px; }
        #canvasContainer { border: 2px solid black; display: inline-block; }
        canvas { background-color: #f0f0f0; }
    </style>
</head>
<body>
    <h1>Canvas & SVG図形変形ツール</h1>
    <div id="controls">
        <input type="file" id="svgFile" accept=".svg">
        <input type="range" id="vertexCount" min="3" max="50" value="20">
        <label for="vertexCount">頂点数: <span id="vertexCountValue">20</span></label>
        <input type="range" id="roundness" min="0" max="100" value="0">
        <label for="roundness">丸み: <span id="roundnessValue">0</span></label>
        <input type="range" id="rotation" min="0" max="360" value="0">
        <label for="rotation">回転: <span id="rotationValue">0</span>°</label>
    </div>
    <div id="canvasContainer">
        <canvas id="canvas" width="400" height="400"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        let svgPathPoints = [];

        document.getElementById('svgFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = event.target.result;
                const svgElement = tempContainer.querySelector('svg');
                const paths = svgElement.querySelectorAll('path');

                svgPathPoints = [];
                paths.forEach(path => {
                    const pathData = new Path2D(path.getAttribute('d'));
                    extractPointsFromPath(pathData);
                });

                updateShape();
            };
            reader.readAsText(file);
        });

        document.getElementById('vertexCount').addEventListener('input', updateShape);
        document.getElementById('roundness').addEventListener('input', updateShape);
        document.getElementById('rotation').addEventListener('input', updateShape);

        function updateShape() {
            const vertexCount = parseInt(document.getElementById('vertexCount').value);
            const roundness = parseInt(document.getElementById('roundness').value) / 100;
            const rotation = parseInt(document.getElementById('rotation').value) * Math.PI / 180;

            document.getElementById('vertexCountValue').textContent = vertexCount;
            document.getElementById('roundnessValue').textContent = roundness * 100;
            document.getElementById('rotationValue').textContent = (rotation * (180 / Math.PI)).toFixed(0);

            drawShape(vertexCount, roundness, rotation);
        }

        function extractPointsFromPath(path) {
            // 簡易的にSVGパスの座標を取得 (詳細にはCanvas APIを使用)
            const length = path.getTotalLength();
            const steps = 100;  // 100ステップで近似

            for (let i = 0; i <= steps; i++) {
                const point = path.getPointAtLength((i / steps) * length);
                svgPathPoints.push({ x: point.x, y: point.y });
            }
        }

        function drawShape(vertexCount, roundness, rotation) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // 画面をクリア

            if (svgPathPoints.length === 0) return;

            const radius = 150;  // 図形の大きさ
            const angleStep = (Math.PI * 2) / vertexCount;  // 各頂点の角度のステップ

            ctx.save();
            ctx.translate(centerX, centerY);  // 中心をキャンバスの中央に設定
            ctx.rotate(rotation);  // 回転を適用

            ctx.beginPath();
            for (let i = 0; i < vertexCount; i++) {
                const t = i / vertexCount;
                const point = getPointAtPercentage(t);
                const prevT = (i - 1 + vertexCount) % vertexCount / vertexCount;
                const prevPoint = getPointAtPercentage(prevT);

                // 丸みを加えるための制御点
                const midX = (point.x + prevPoint.x) / 2;
                const midY = (point.y + prevPoint.y) / 2;
                const dx = point.x - prevPoint.x;
                const dy = point.y - prevPoint.y;
                const normX = -dy;
                const normY = dx;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const controlX = midX + (normX / dist) * dist * roundness;
                const controlY = midY + (normY / dist) * dist * roundness;

                if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.quadraticCurveTo(controlX, controlY, point.x, point.y);
                }
            }
            ctx.closePath();
            ctx.stroke();  // 図形の輪郭を描画
            ctx.restore();
        }

        function getPointAtPercentage(t) {
            const totalLength = svgPathPoints.length;
            const index = Math.floor(t * totalLength);
            const nextIndex = (index + 1) % totalLength;
            const point1 = svgPathPoints[index];
            const point2 = svgPathPoints[nextIndex];

            const segmentT = (t * totalLength) % 1;

            return {
                x: point1.x + (point2.x - point1.x) * segmentT,
                y: point1.y + (point2.y - point1.y) * segmentT
            };
        }

        // 初期状態で描画を行うための関数
        updateShape();
    </script>
</body>
</html>
