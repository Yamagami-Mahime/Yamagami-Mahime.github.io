<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG図形変形ツール（400px×400px版）- 元の形状を保持</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-bottom: 20px; }
        input { margin-right: 10px; }
        #svgContainer { border: 2px solid black; }
    </style>
</head>
<body>
    <h1>SVG図形変形ツール（400px×400px版）- 元の形状を保持</h1>
    <div id="controls">
        <input type="file" id="svgFile" accept=".svg">
        <input type="range" id="vertexCount" min="3" max="20" value="4">
        <label for="vertexCount">頂点数: <span id="vertexCountValue">4</span></label>
        <input type="range" id="roundness" min="0" max="100" value="0">
        <label for="roundness">丸み: <span id="roundnessValue">0</span></label>
        <input type="range" id="rotation" min="0" max="360" value="0">
        <label for="rotation">回転: <span id="rotationValue">0</span>°</label>
    </div>
    <svg id="svgContainer" width="400" height="400"></svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.1/svg.min.js"></script>
    <script>
        const svgContainer = SVG('#svgContainer');
        let originalShape;
        let transformedShape;

        document.getElementById('svgFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                svgContainer.clear();
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = event.target.result;
                const svgElement = tempContainer.querySelector('svg');
                const viewBox = svgElement.getAttribute('viewBox');
                if (viewBox) {
                    svgContainer.attr('viewBox', viewBox);
                }
                originalShape = SVG(svgElement.querySelector('path'));
                svgContainer.add(originalShape);
                transformedShape = originalShape.clone();
                svgContainer.add(transformedShape);
                centerAndScaleShape();
                analyzeShape();
                updateShape();
            };
            reader.readAsText(file);
        });

        ['vertexCount', 'roundness', 'rotation'].forEach(id => {
            const input = document.getElementById(id);
            const value = document.getElementById(`${id}Value`);
            input.addEventListener('input', () => {
                value.textContent = input.value;
                updateShape();
            });
        });

        function centerAndScaleShape() {
            const bbox = originalShape.bbox();
            const scale = Math.min(380 / bbox.width, 380 / bbox.height);
            originalShape.transform({
                translateX: (400 - bbox.width * scale) / 2 - bbox.x * scale,
                translateY: (400 - bbox.height * scale) / 2 - bbox.y * scale,
                scale: scale
            });
            transformedShape.transform(originalShape.transform());
        }

        let vertices = [];

        function analyzeShape() {
            const pathData = originalShape.array();
            vertices = [];
            for (let i = 0; i < pathData.length; i++) {
                const segment = pathData[i];
                if (segment[0] === 'M' || segment[0] === 'L') {
                    vertices.push({x: segment[1], y: segment[2]});
                } else if (segment[0] === 'C') {
                    vertices.push({x: segment[5], y: segment[6]});
                }
            }
        }

        function updateShape() {
            if (!originalShape) return;

            const vertexCount = parseInt(document.getElementById('vertexCount').value);
            const roundness = parseInt(document.getElementById('roundness').value) / 100;
            const rotation = parseInt(document.getElementById('rotation').value);

            let newPath = '';
            const center = originalShape.bbox().center;

            for (let i = 0; i < vertexCount; i++) {
                const angle = (i / vertexCount) * Math.PI * 2 + (rotation * Math.PI / 180);
                const nextAngle = ((i + 1) / vertexCount) * Math.PI * 2 + (rotation * Math.PI / 180);
                
                const vertex = getInterpolatedVertex(angle);
                const nextVertex = getInterpolatedVertex(nextAngle);

                if (i === 0) {
                    newPath += `M${vertex.x},${vertex.y}`;
                }

                const midX = (vertex.x + nextVertex.x) / 2;
                const midY = (vertex.y + nextVertex.y) / 2;
                const dx = nextVertex.x - vertex.x;
                const dy = nextVertex.y - vertex.y;
                const normX = -dy;
                const normY = dx;
                const dist = Math.sqrt(normX * normX + normY * normY);
                const controlX = midX + (normX / dist) * dist * roundness / 2;
                const controlY = midY + (normY / dist) * dist * roundness / 2;

                newPath += `Q${controlX},${controlY} ${nextVertex.x},${nextVertex.y}`;
            }

            newPath += 'Z';
            transformedShape.plot(newPath);
        }

        function getInterpolatedVertex(angle) {
            const center = originalShape.bbox().center;
            let minDist = Infinity;
            let closestVertex = null;

            for (let vertex of vertices) {
                const dx = vertex.x - center.x;
                const dy = vertex.y - center.y;
                const vertexAngle = Math.atan2(dy, dx);
                const angleDiff = Math.abs(normalizeAngle(vertexAngle - angle));
                if (angleDiff < minDist) {
                    minDist = angleDiff;
                    closestVertex = vertex;
                }
            }

            return closestVertex;
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }
    </script>
</body>
</html>
