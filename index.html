<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG図形変形ツール（400px×400px版）- 複雑な形状にも対応</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #controls { margin-bottom: 20px; }
        input { margin-right: 10px; }
        #svgContainer { border: 2px solid black; }
    </style>
</head>
<body>
    <h1>SVG図形変形ツール（400px×400px版）- 複雑な形状にも対応</h1>
    <div id="controls">
        <input type="file" id="svgFile" accept=".svg">
        <input type="range" id="vertexCount" min="3" max="50" value="20">
        <label for="vertexCount">頂点数: <span id="vertexCountValue">20</span></label>
        <input type="range" id="roundness" min="0" max="100" value="0">
        <label for="roundness">丸み: <span id="roundnessValue">0</span></label>
        <input type="range" id="rotation" min="0" max="360" value="0">
        <label for="rotation">回転: <span id="rotationValue">0</span>°</label>
    </div>
    <svg id="svgContainer" width="400" height="400"></svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.1/svg.min.js"></script>
    <script>
        const svgContainer = SVG('#svgContainer');
        let originalShape;
        let transformedShape;

        document.getElementById('svgFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                svgContainer.clear();
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = event.target.result;
                const svgElement = tempContainer.querySelector('svg');
                const viewBox = svgElement.getAttribute('viewBox');
                if (viewBox) {
                    svgContainer.attr('viewBox', viewBox);
                }
                originalShape = SVG(svgElement.querySelector('path'));
                svgContainer.add(originalShape);
                transformedShape = originalShape.clone();
                svgContainer.add(transformedShape);
                centerAndScaleShape();
                analyzeShape();
                updateShape();
            };
            reader.readAsText(file);
        });

        ['vertexCount', 'roundness', 'rotation'].forEach(id => {
            const input = document.getElementById(id);
            const value = document.getElementById(`${id}Value`);
            input.addEventListener('input', () => {
                value.textContent = input.value;
                updateShape();
            });
        });

        function centerAndScaleShape() {
            const bbox = originalShape.bbox();
            const scale = Math.min(380 / bbox.width, 380 / bbox.height);
            originalShape.transform({
                translateX: (400 - bbox.width * scale) / 2 - bbox.x * scale,
                translateY: (400 - bbox.height * scale) / 2 - bbox.y * scale,
                scale: scale
            });
            transformedShape.transform(originalShape.transform());
        }

        let pathPoints = [];

        function analyzeShape() {
            const pathData = originalShape.array();
            pathPoints = [];
            let currentPoint = null;
            for (let i = 0; i < pathData.length; i++) {
                const segment = pathData[i];
                switch (segment[0]) {
                    case 'M':
                    case 'L':
                        currentPoint = {x: segment[1], y: segment[2]};
                        pathPoints.push(currentPoint);
                        break;
                    case 'C':
                        pathPoints.push(
                            {x: segment[1], y: segment[2]},
                            {x: segment[3], y: segment[4]},
                            {x: segment[5], y: segment[6]}
                        );
                        currentPoint = {x: segment[5], y: segment[6]};
                        break;
                    case 'Q':
                        pathPoints.push(
                            {x: segment[1], y: segment[2]},
                            {x: segment[3], y: segment[4]}
                        );
                        currentPoint = {x: segment[3], y: segment[4]};
                        break;
                }
            }
        }

        function updateShape() {
            if (!originalShape) return;

            const vertexCount = parseInt(document.getElementById('vertexCount').value);
            const roundness = parseInt(document.getElementById('roundness').value) / 100;
            const rotation = parseInt(document.getElementById('rotation').value) * Math.PI / 180;

            let newPath = '';
            const center = originalShape.bbox().center;

            for (let i = 0; i < vertexCount; i++) {
                const t = i / vertexCount;
                const point = getPointAtPercentage(t);
                const rotatedPoint = rotatePoint(point, center, rotation);

                if (i === 0) {
                    newPath += `M${rotatedPoint.x},${rotatedPoint.y}`;
                } else {
                    const prevT = (i - 1) / vertexCount;
                    const prevPoint = getPointAtPercentage(prevT);
                    const rotatedPrevPoint = rotatePoint(prevPoint, center, rotation);

                    const midX = (rotatedPrevPoint.x + rotatedPoint.x) / 2;
                    const midY = (rotatedPrevPoint.y + rotatedPoint.y) / 2;
                    const dx = rotatedPoint.x - rotatedPrevPoint.x;
                    const dy = rotatedPoint.y - rotatedPrevPoint.y;
                    const normX = -dy;
                    const normY = dx;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const controlX = midX + (normX / dist) * dist * roundness / 2;
                    const controlY = midY + (normY / dist) * dist * roundness / 2;

                    newPath += `Q${controlX},${controlY} ${rotatedPoint.x},${rotatedPoint.y}`;
                }
            }

            newPath += 'Z';
            transformedShape.plot(newPath);
        }

        function getPointAtPercentage(t) {
            const totalLength = pathPoints.length;
            const index = Math.floor(t * (totalLength - 1));
            const nextIndex = (index + 1) % totalLength;
            const segmentT = (t * (totalLength - 1)) % 1;

            const point1 = pathPoints[index];
            const point2 = pathPoints[nextIndex];

            return {
                x: point1.x + (point2.x - point1.x) * segmentT,
                y: point1.y + (point2.y - point1.y) * segmentT
            };
        }

        function rotatePoint(point, center, angle) {
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            return {
                x: center.x + dx * Math.cos(angle) - dy * Math.sin(angle),
                y: center.y + dx * Math.sin(angle) + dy * Math.cos(angle)
            };
        }
    </script>
</body>
</html>
